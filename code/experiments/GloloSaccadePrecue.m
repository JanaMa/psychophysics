function e = GloloSaccadePrecue(varargin)
    e = Experiment(varargin{:});
    
    its = Genitive();
    
    e.trials.base = GloloSaccadeTrial...
        ( 'extra', struct...
            ( 'minSpace', 12 ...
            , 'distractorRelativeContrast', 1 ...
            , 'r', 12 ...
            , 'dx', [2.25 2.25] ...
            , 'dt', [.15 .15] ...
            , 'l', 1.125 ...
            , 'color', [0.25;0.25;0.25] ...
            , 'targetDirection', [0 0] ...
            , 'localVScalar', [0 0] ...
            ) ... 
        , 'fixation', FilledDisk ...
            ( 'radius', 0.2 ...
            , 'loc', [0 0] ...
            ) ...
        , 'fixationTime', Inf ...
        , 'fixationLatency', 1.0 ...
        , 'fixationStartWindow', 2 ...
        , 'fixationSettle', 0.4 ...
        , 'fixationWindow', 3 ...
        , 'targetOnset', 0 ...
        , 'usePrecue', 1 ...
        , 'precueOnset', 0 ...
        , 'precueDuration', 0.1 ...
        , 'precue', CauchyDrawer ...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', 8 ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', 1.125 ...
                , 'order', 4 ...
                )...
            )...
        , 'target', CauchyDrawer ...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', 8 ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', .75 ...
                , 'order', 4 ...
                )...
            ) ...
        , 'useTrackingTarget', 1 ...
        , 'trackingTarget', CauchySpritePlayer ...
            ('process', CircularCauchyMotion ...
                ( 'radius', 8 ...
                , 'dt', .15 ...
                , 'dphase', [1.5/8 -1.5/8] ...
                , 'x', 0 ...
                , 'y', 0 ...
                , 't', .15 ...
                , 'n', [Inf Inf] ...
                , 'color', [0.5 0.5 0.5]' ...
                , 'velocity', 10 ... %velocity of peak spatial frequency
                , 'wavelength', 0.75 ...
                , 'width', .75 ...
                , 'duration', 0.1 ...
                , 'order', 4 ...
                , 'phase', [0 0] ...
                , 'angle', [90 90] ...
                ) ...
            ) ...
        , 'targetBlank', Inf ...
        , 'cueTime', Inf ... %assuming 200ms latency, this places most saccades right in between for max. effect
        , 'maxLatency', 0.4 ...
        , 'maxTransitTime', 0.1 ...
        , 'targetWindow', 8 ...
        , 'rewardSize', 300 ...
        , 'rewardTargetBonus', 0.0 ...
        , 'errorTimeout', 0.0 ...
        , 'earlySaccadeTimeout', 3.0 ...
        );
    
    %the targets move clockwise or counterclockwise at a certain speed.
    %There is a distractor target whose motion is also randomized. The
    %local velocities are also scaled.
    e.trials.add('extra.targetDirection(1)', [1 -1]);
    e.trials.add('extra.targetDirection(2)', [1 -1]);
    e.trials.add('extra.localVScalar(1)', [-1.5 -1 -0.5 0.5 1 1.5]);
    e.trials.add('extra.localVScalar(2)', [-1.5 -1 -0.5 0.5 1 1.5]);
    e.trials.add('target.source.phase(1)', UniformDistribution('lower', 0, 'upper', 2*pi));
    e.trials.add('extra.distractorPhaseSeed', UniformDistribution('lower', 0, 'upper', 1));

    %dammit, try rewarding him for fixation sometimes. this is measured
    %from fixation acquisition. So compare with targetOnset + cueTime
    e.trials.add('fixationTime', ExponentialDistribution('offset', 1, 'tau', 0.6));

    %the target onset comes at a somewhat unpredictable time.
    e.trials.add('targetOnset', ExponentialDistribution('offset', 1, 'tau', 0.5));
    
    %the cue time...
    e.trials.add('cueTime', ExponentialDistribution('offset', 0.6, 'tau', 0.3));

    %the precue comes 300 ms before the target osnet.
    e.trials.add('precueOnset', @(b)b.targetOnset - 0.2);
    
    %target tracking timeq
    e.trials.add('targetFixationTime', ExponentialDistribution('offset', 0.3, 'tau', 0.2));
    
    e.trials.add([], @globalAppearance);
    function b = globalAppearance(b)
        %procedurally set up the global appearance...
        extra = b.extra;
        
        targetSource = b.target.source;
        targetSource.setRadius(extra.r);
        targetSource.setOmega(extra.dx(1) ./ extra.dt(1) ./ extra.r(1) .* extra.targetDirection(1));
        targetSource.setAngle(targetSource.getPhase() * 180/pi + 90);

        trackingProcess = b.trackingTarget.process;
        trackingProcess.setRadius(extra.r);
        trackingProcess.setDt(extra.dt);
        trackingProcess.setT(extra.dt);
        ph = (targetSource.getPhase() + trackingProcess.getT() .* targetSource.getOmega());
        trackingProcess.property__(its.phase(1), ph(1));
        trackingProcess.setDphase(extra.dx / extra.r .* extra.targetDirection);
        
        %set the location of the distractor target so as not to overlap
        %with the normal target.      
        [ns, pps] = trackingProcess.property__();
        t = min(b.cueTime, b.fixationTime - b.targetOnset) + b.maxLatency - pps.t(1);
        
        %how much of an arc does the target traverse from the perspective
        %of the distractor?
        arc = pps.dphase./pps.dt.*t * [1;-1];
        
        %this is either a positive or a negative number. the distractor
        %must start somewhere so that it doesn't overlap the object.
        dist = b.extra.minSpace ./ pps.radius;
        ccwOf = max(pps.phase(1) + dist, pps.phase(1) + dist + arc);
        cwOf = min(pps.phase(1) - dist, pps.phase(1) - dist + arc) + 2 + pi;
        
        if (cwOf < ccwOf)
            % no space for a stimulus that long. Oops. React by
            % reducing n so that the target disappears after a bit.
            if arc > 1
                trackingProcess.property__(its.phase(2), cwOf);
            else
                trackingProcess.property__(its.phase(2), ccwOf);
            end
            trackingProcess.property__(its.n(2), floor(2*(pi-dist)*t/abs(arc)/pps.dt(2)));
        else
            %reset n...
            trackingProcess.property__(its.phase(2), b.extra.distractorPhaseSeed() * (cwOf-ccwOf) + ccwOf);
            trackingProcess.property__(its.n(2), trackingProcess.property__(its.n(1)));
        end

        %finally orient the stimuli...
        trackingProcess.setAngle(trackingProcess.getPhase() * 180/pi + 90);

        precueSource = b.precue.source;
        precueSource.setRadius(extra.r);
        precueSource.setPhase(targetSource.getPhase());
        precueSource.setAngle(targetSource.getAngle());
    end
        
    %We manipulate the local velocities. both in wavelength-scaling and in frequency-scaling.    
    e.trials.add([], @localAppearance);
    function b = localAppearance(b)
        extra = b.extra;
        trackingProcess = b.trackingTarget.process;
        
        trackingProcess.setVelocity(extra.dx ./ extra.dt .* [extra.targetDirection] .* [extra.localVScalar]);
        trackingProcess.setColor([extra.color ./ abs(extra.localVScalar(1)), extra.color ./ abs(extra.localVScalar(2)) .* extra.distractorRelativeContrast]);
        trackingProcess.setWavelength(extra.l .* extra.localVScalar);
        
        %Make sure that after the changeover to the smooth target, the target
        %stll has the same (mean) contrast and wavelength.
        targetSource = b.target.source;
        targetSource.setColor(trackingProcess.property__(its.color(:,1)) .* trackingProcess.property__(its.duration(1)) ./ trackingProcess.property__(its.dt(1)));
        targetSource.setWavelength(trackingProcess.property__(its.wavelength(:,1)));
        
        precueSource = b.precue.source;
        precueSource.setColor(targetSource.getColor());
        precueSource.setWavelength(targetSource.getWavelength());
    end
        
    %there if using the tracking target, shift back the target onset a
    %bit. (why was I doing this??)
%    e.trials.add('targetOnset', @(b)b.targetOnset + b.useTrackingTarget * dx);

    %minimize time between trials.
    e.trials.interTrialInterval = 0;
    
%    e.trials.fullFactorial = 1;
%    e.trials.reps = 30;
    e.trials.blockSize = 300;
    
    e.trials.requireSuccess = 0;
    
    %begin with an eye calibration and again every couple hundred trials...
    %
    e.trials.blockTrial = EyeCalibrationMessageTrial...
        ( its.base.absoluteWindow, 100 ...
        , its.base.maxLatency, 0.5 ...
        , its.base.fixDuration, 1 ...
        , its.base.fixWindow, 4 ...
        , its.base.rewardDuration, 50 ...
        , its.base.settleTime, 0.4 ...
        , its.base.targetRadius, 0.2 ...
        , its.minCalibrationInterval, 900 ...
        , its.base.onset, 0 ...
        , its.maxStderr, 0.3 ...
        , its.minN, 20 ...
        , its.maxN, 50 ...
        , its.interTrialInterval, 0.2 ...
        );
    
        %
end
