function e = GloloSaccadePrecue(varargin)
    e = Experiment(varargin{:});
    
    its = Genitive();
    
    r = 8;
    dx = 1.5;
    dt = 0.15;
    v = dx/dt;
    l = 0.75;
    
    e.trials.base = GloloSaccadeTrial...
        ( 'extra', struct('minSpace', 5) ... 
        , 'fixation', FilledDisk ...
            ( 'radius', 0.1 ...
            , 'loc', [0 0] ...
            ) ...
        , 'fixationOnset', 0 ...
        , 'fixationTime', Inf ...
        , 'fixationLatency', 1.0 ...
        , 'fixationStartWindow', 2 ...
        , 'fixationSettle', 0.4 ...
        , 'fixationWindow', 3 ...
        , 'targetOnset', 0 ...
        , 'usePrecue', 1 ...
        , 'precueOnset', 0 ...
        , 'precueDuration', 0.1 ...
        , 'precue', CauchyDrawer ...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', r ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', .75 ...
                , 'order', 4 ...
                )...
            )...
        , 'target', CauchyDrawer ...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', r ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', .75 ...
                , 'order', 4 ...
                )...
            ) ...
        , 'useTrackingTarget', 1 ...
        , 'trackingTarget', CauchySpritePlayer ...
            ('process', CircularCauchyMotion ...
                ( 'radius', r ...
                , 'dt', dt ...
                , 'dphase', [dx/r -dx/r] ...
                , 'x', 0 ...
                , 'y', 0 ...
                , 't', dt ...
                , 'n', Inf ...
                , 'color', [0.5 0.5 0.5]' ...
                , 'velocity', v ... %velocity of peak spatial frequency
                , 'wavelength', 0.75 ...
                , 'width', .75 ...
                , 'duration', 0.1 ...
                , 'order', 4 ...
                , 'phase', [0 0] ...
                , 'angle', [90 90] ...
                ) ...
            ) ...
        , 'targetBlank', Inf ...
        , 'cueTime', 0.625 ... %assuming 200ms latency, this places most saccades right in between for max. effect
        , 'maxLatency', 0.4 ...
        , 'maxTransitTime', 0.1 ...
        , 'targetWindow', 5 ...
        , 'rewardSize', 50 ...
        , 'rewardTargetBonus', 0.0 ...
        , 'errorTimeout', 0.0 ...
        );
    
    %the targets move clockwise or counterclockwise at a certain speed.
    %There is a distractor target whose motion is also randomized.
    e.trials.add({'target.source.omega', 'trackingTarget.process.dphase'}, ...
        { {-v/r [-dx/r  dx/r]} ...
        , {-v/r [-dx/r -dx/r]} ...
        , { v/r [ dx/r  dx/r]} ...
        , { v/r [ dx/r -dx/r]} ...
        } );

    %the target onset comes at a somewhat unpredictable time.
    e.trials.add('targetOnset', ExponentialDistribution('offset', 0.5, 'tau', 0.15));
    
    %the precue comes 300 ms before the target osnet.
    e.trials.add('precueOnset', @(b)b.targetOnset - 0.2);
    
    %the cue time...
    e.trials.add('cueTime', ExponentialDistribution('offset', 0.45, 'tau', 0.25));

    %the two targets come up at an unknown location around the circle.
    e.trials.add('target.source.phase(1)', UniformDistribution('lower', 0, 'upper', 2*pi));
    e.trials.add('target.source.angle', @(b) b.target.source.phase * 180/pi + 90);
    e.trials.add('trackingTarget.process.phase(1)', @(b) (b.target.source.phase + b.trackingTarget.process.t * b.target.source.omega));
    e.trials.add('extra.distractorPhaseSeed', UniformDistribution('lower', 0, 'upper', 1));
    e.trials.add('trackingTarget.process.phase(2)', @pickDistractorPhase);
    e.trials.add('trackingTarget.process.angle', @(b) (b.trackingTarget.process.phase * 180/pi + 90));
    e.trials.add('precue.source.phase', @(b) b.target.source.phase);
    e.trials.add('precue.source.angle', @(b) b.target.source.angle);
    
    %We manipulate the local velocities. both in wavelength-scaling and in frequency-scaling.    
        e.trials.add...
            ( { its.useTrackingTarget ...
              , its.extra.wavelengthScaling ...
              , its.trackingTarget.process.velocity ...
              , its.trackingTarget.process.color ...
              , its.trackingTarget.process.wavelength ...
              } ...
            , ...
                { {1 1    v/2      [.5    .5   .5  ]' .5*l } ...
                , {1 1   -v/2      [.5    .5   .5  ]' .5*l } ...
                , {1 0.5  v        [.25   .25  .25 ]' l*l  } ...
                , {1 0.5 -v        [.25   .25  .25 ]' l*l  } ...
                , {1 1    1.5*v    [1/6   1/6  1/6 ]' 1.5*l} ...
                , {1 1   -1.5*v    [1/6   1/6  1/6 ]' 1.5*l} ...
                } ...
            );
    
    %the distractor target motion gets added on and manipulated independently:
        e.trials.add...
            ( { its.trackingTarget.process.velocity(2)    ...
              , its.trackingTarget.process.color(:,2)     ...
              , its.trackingTarget.process.wavelength(2) ...
              } ...
            , { {  v/2      [.5    .5   .5  ]' l/2  } ...
              , { -v/2      [.5    .5   .5  ]' l/2  } ...
              , {  v        [.25   .25  .25 ]' l    } ...
              , { -v        [.25   .25  .25 ]' l    } ...
              , {  1.5*v    [1/6   1/6  1/6 ]' 1.5*l} ...
              , { -1.5*v    [1/6   1/6  1/6 ]' 1.5*l} ...
              } ...
            );
        
     %there if using the tracking target, shift back the target onset a
     %bit. (why was I doing this??)
%    e.trials.add('targetOnset', @(b)b.targetOnset + b.useTrackingTarget * dx);

    %TODO: then the phase gets twiddled so that the two targets do not
    %overlap at any point.
    
    %Make sure that after the changeover to the smooth target, the target
    %stll has the same mean contrast and wavelength.
    e.trials.add ...
        ( {'target.source.color', 'target.source.wavelength'} ...
        , @(b) {b.trackingTarget.process.color(:,1) * b.trackingTarget.process.duration(1) / b.trackingTarget.process.dt(1), b.trackingTarget.process.wavelength(1)} ...
        );
    
    %the precue looks simialr to the target.
    e.trials.add('precue.source.color', @(b)b.target.source.color);
    e.trials.add('precue.source.wavelength', @(b)b.target.source.wavelength);
    
    %minimize time between trials.
    e.trials.interTrialInterval = 0;
    
    e.trials.fullFactorial = 1;
    e.trials.reps = 30;
    e.trials.blockSize = 170;
    
    e.trials.requireSuccess = 1;
        
    %target tracking time
    e.trials.add('targetFixationTime', ExponentialDistribution('offset', 0.3, 'tau', 0.2));
    
    %begin with an eye calibration and again every 15 minutes...
    %{
    e.trials.blockTrial = EyeCalibrationMessageTrial...
        ( its.base.absoluteWindow, 100 ...
        , its.base.maxLatency, 0.5 ...
        , its.base.fixDuration, 0.5 ...
        , its.base.fixWindow, 4 ...
        , its.base.rewardDuration, 100 ...
        , its.base.settleTime, 0.4 ...
        , its.base.targetRadius, 0.2 ...
        , its.minCalibrationInterval, 900 ...
        , its.base.onset, 0 ...
        , its.maxStderr, 0.3 ...
        , its.minN, 20 ...
        , its.maxN, 50 ...
        , its.interTrialInterval, 0.2 ...
        );
    
    e.trials.startTrial = MessageTrial('message', @()sprintf('Follow the moving target with your eyes when fixation point diasappears.\n%d blocks remain.\nPress space to begin calibration.', e.trials.blocksLeft()));
    e.trials.endBlockTrial = MessageTrial('message', @()sprintf('%d blocks remain.\nPress space to continue.', e.trials.blocksLeft()));
    e.trials.endTrial = MessageTrial('message', sprintf('All done!\nPress space to finish.\nThanks!'));
    %}
    function phase = pickDistractorPhase(b)
        %function {trackingTarget.process.phase(2)} = pickSecondTarget(b)
        %Make up a distractor tracking target. Only works when the "tracking
        %target" is enabled.
        
        [ns, pps] = b.trackingTarget.process.property__();
        t = b.cueTime + b.maxLatency - pps.t;
        
        %how much of an arc does the target traverse from the perspective
        %of the distractor?
        arc = pps.dphase./pps.dt.*t * [1;-1];
        
        %this is either a positive or a negative number. the distractor
        %must start somewhere so that it doesn't overlap the object.
        dist = b.extra.minSpace ./ pps.radius;
        ccwOf = max(pps.phase(1) + dist, pps.phase(1) + dist + arc)
        cwOf = min(pps.phase(1) - dist, pps.phase(1) - dist + arc) + 2 + pi
        
        if (cwOf < ccwOf)
            noop();
        end
        
        phase = b.extra.distractorPhaseSeed() * (cwOf-ccwOf) + ccwOf;
        
        noop();
    end
end
