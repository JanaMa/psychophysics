function e = ConcentricOculomotor(varargin)
    e = Experiment('params.inputUsed', {'eyes', 'keyboard', 'audioout'}, varargin{:});
    
    its = Genitive();
    
    densitySet = unique(round(1./logspace(log10(1/4), log10(1/30), 16)));
    
    e.trials.base = ConcentricOculomotorTrial...
        ( 'extra', struct...
            ( 'r', 20/3 ...
            , 'globalVScalar', 0.75 ...
            , 'tf', 10 ...
            , 'wavelengthScalar', .075 ...
            , 'dt', 0.1 ...
            , 'widthScalar', 0.075 ...
            , 'durationScalar', 2/3 ...
            , 'phase', 0 ...
            , 'globalDirection', 1 ...
            , 'localDirection', 1 ...
            , 'color', [0.5;0.5;0.5] / sqrt(2) ...
            , 'directionContrast', 1 ...
            , 'minSpace', 12 ...
            , 'distractorRelativeContrast', 1 ...
            , 'nTargets', 2 ...
            , 'nStrokes', Inf ...
            ) ...
        , 'fixation', FilledDisk ...
            ( 'radius', 0.1 ...
            , 'loc', [0 0] ...
            ) ...
        , 'fixationTime', Inf ...
        , 'fixationLatency', 1.0 ...
        , 'fixationStartWindow', 3 ...
        , 'fixationSettle', 0.2 ...
        , 'fixationWindow', 2 ...
        , 'targetOnset', 0 ...
        , 'usePrecue', 1 ...
        , 'precueOnset', 0 ...
        , 'precueDuration', 0.1 ...
        , 'precue', CauchyDrawer ...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', 8 ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', 1 ...
                , 'order', 4 ...
                )...
            )...
        , 'target', CauchyDrawer ...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', 8 ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', 1 ...
                , 'order', 4 ...
                )...
            ) ...
        , 'useTrackingTarget', 1 ...
        , 'trackingTarget', CauchySpritePlayer ...
            ('process', CircularCauchyMotion ...
                ( 'radius', 8 ...
                , 'dt', .15 ...
                , 'dphase', [1.5/8] ...
                , 'x', 0 ...
                , 'y', 0 ...
                , 't', .15 ...
                , 'n', [Inf] ...
                , 'color', [0.5 0.5 0.5]' ...
                , 'velocity', 10 ... %velocity of peak spatial frequency
                , 'wavelength', 0.75 ...
                , 'width', 1 ...
                , 'duration', [0.1 0.1] ...
                , 'order', 4 ...
                , 'phase', [0 0] ...
                , 'angle', [90 90] ...
                ) ...
            ) ...
        , 'targetBlank', Inf ...
        , 'cueTime', Inf ... %assuming 200ms latency, this places most saccades right in between for max. effect
        , 'minLatency', 0.075 ... %too short a latency counts as jumping the gun
        , 'maxLatency', 0.6 ...
        , 'maxTransitTime', 0.15 ...
        , 'targetWindow', 4 ...
        , 'rewardSize', 0 ...
        , 'rewardTargetBonus', 0.15 ...
        , 'rewardLengthBonus', 0.15 ...
        , 'errorTimeout', 0 ...
        , 'earlySaccadeTimeout', 3.0 ...
        );
    
%%
    %In this section, we build up the array of parameters we will staircase with.
    vars = {};
    
    %vars(end+1,:) = {{'extra.r', 'targetWindow'}, {{10 20/3}}};
    vars(end+1,:) = {{'extra.r', 'targetWindow'}, {{10 20/3} {20/3 40/9} {40/9 80/27}}};
    %vars(end+1,:) = {{'extra.r', 'targetWindow'}, {{10 20/3} {20/3 40/9} {40/9 80/27}}};
        
    vars(end+1,:) = {{'extra.directionContrast'}, {0.2 0.4 1.0}};
    
    %temporal frequency is chosen here...
    %%vars(end+1,:) = {{'extra.tf'}, {15 10 20/3}};
    vars(end+1,:) = {{'extra.tf'}, {10}};

    %and wavelength is set to the RADIUS multiplied by this (note
    %this is independent of dt or dx)
    %%vars(end+1,:) = {{'extra.wavelengthScalar'}, {2/30 .1 .15}};
    vars(end+1,:) = {{'extra.wavelengthScalar'}, {.075}};
    
    %dt changes independently of it all. but it is linked to the stimulus
    %duration.
    %%vars(end+1,:) = {{'extra.dt'}, {2/30 0.10 0.15}};
    vars(end+1,:) = {{'extra.dt'}, {0.10}};

    %expand all the values to be used here.
    parameters = cat(2, vars{:,1});
    indices = fullfact(cellfun('prodofsize', vars(:,2)));

    product = cellfun(@(row)cellfun(@(x,y)x(y), vars(:,2)', num2cell(row)), num2cell(indices, 2), 'UniformOutput', 0);
    product = cellfun(@(row)cat(2, row{:}), product, 'UniformOutput', 0);

    %now create staircases for each... use 2-down, one up for this
    parameters{end+1} = 'extra.nTargets';
    for i = 1:numel(product)
        product{i}{end+1} = DiscreteStaircase ...
            ( 'valueSet', densitySet, 'currentIndex', 12 ...
            , 'Nup', 3, 'Ndown', 1 ...
            , 'useMomentum', 1 ...
            , 'criterion', @criterion ...
            );
    end
    
    function crowded = criterion(trial, result)
        %gloloSaccadeTrial returns result.success = 1 only if cued AND subject
        %tracked successfuly;
        %0 if cued and saccade failed;
        %else NaN.
        
        crowded = 0;
        if result.success == 1
            crowded = -1
        elseif result.success == 0;
            crowded = 1
        else
            crowded = 0
        end
    end
    
    %now add'em all
    e.trials.add(parameters, product);
%%

    %equal distribution of concruent and incongruent, to avoid cuing.
    e.trials.add('extra.globalDirection', [1 -1]);
        e.trials.add('extra.localDirection', [1 -1])
                 
    %I'm also going to put global speed outside the staircase.
    %That way density is not aq cue for local vs. global.
    e.trials.add('extra.globalVScalar', [1.125 0.75 0.5 0.3]);
    
    %The durations are 2/3 of the dt, at the same global speed
    e.trials.add('trackingTarget.process.duration', @(b)b.extra.dt * 2/3);

    %The target appears on the screen somewhere (but we don't know where
    %the distracctor is yet)
    e.trials.add('target.source.phase(1)', UniformDistribution('lower', 0, 'upper', 2*pi));
    
    %the target onset comes at a somewhat unpredictable time.
    e.trials.add('targetOnset', ExponentialDistribution('offset', 0.3, 'tau', 0.2));
    
    %the cue time comes on unpredictably after the target onset.
    e.trials.add('cueTime', ExponentialDistribution('offset', 0.2, 'tau', 0.3));

    %But on some of trials the monkey is rewarded for just fixating.
    %e.trials.add('fixationTime', GammaDistribution('offset', 0.7, 'shape', 2, 'scale', 0.8));
    
    %Not humans though.
    e.trials.add('fixationTime', Inf);

    %The precue, if there is one, comes 300 ms before the target onset.
    e.trials.add('precueOnset', @(b)b.targetOnset - 0.3);
    
    %The target tracking time is also variable.
    e.trials.add('targetFixationTime', ExponentialDistribution('offset', 0.3, 'tau', 0.2));
    
    %procedurally set up the global appearance of the stimulus
    e.trials.add([], @appearance);
    
    function b = appearance(b)
        %This function procedurally sets up the global appearance.
        extra = b.extra;

        mot = b.trackingTarget.process;
        mot.setRadius(extra.r);
        mot.setDt(extra.dt);
        mot.setT(extra.dt);
        mot.setDphase(extra.dt .* extra.globalVScalar .* sign(extra.globalDirection));
        wl = extra.r * extra.wavelengthScalar;
        mot.setWavelength(wl);
        mot.setWidth(extra.r .* extra.widthScalar);
        mot.setDuration(extra.durationScalar .* extra.dt);
        mot.setN(extra.nStrokes - 1);
        
        %the target moves the same as the motion stimulus.
        targetSource = b.target.source;
        ph = targetSource.property__(its.phase(1));
        targetSource.setRadius(extra.r(1));
        targetSource.setOmega(extra.globalVScalar(1) .* sign(extra.globalDirection));
        targetSource.setAngle(ph * 180/pi + 90);
        
        %local appearance. Note phase is synchronized to the target
        %position.
        wl = extra.r .* extra.wavelengthScalar;
        v = wl .* extra.tf;
        ph = ph + mot.getT() .* targetSource.getOmega() + 2*pi*(0:extra.nTargets-1)/extra.nTargets;
        
        if isfield(extra, 'nVisibleTargets')
            ph = ph(1:extra.nVisibleTargets);
        end
        
        %We don't really use "congruent" any more, jsut specify direction
        %contrast.
        if extra.localDirection == 0 || extra.directionContrast ~= 1
        
            %The ambiguous motion is made up of two opposing motions superimposed,
            %so we have to double and elements (and reduce the contrast)
            %for that onthis.
            ph = reshape(repmat(ph, 2, 1), 1, []);
            mot.setPhase(ph);
            mot.setAngle(mod(ph*180/pi + 90, 360));
            mot.setVelocity(wl .* extra.tf * repmat([1 -1], 1, numel(ph)/2));
            if extra.directionContrast ~= 1
                mot.setVelocity(mot.getVelocity() * extra.localDirection);
                ccc = repmat(extra.color * [1 + extra.directionContrast, 1-extra.directionContrast], 1, numel(ph)/2);
                mot.setColor(ccc);
            else
                mot.setColor(extra.color);            
            end
        else
            mot.setPhase(ph);
            mot.setAngle(mod(ph*180/pi + 90, 360));
            mot.setVelocity(wl .* extra.tf .* extra.localDirection);
            mot.setColor(extra.color);
        end

        mot.setWavelength(wl);
        mot.setWidth(extra.r .* extra.widthScalar);

        %the precue is appears unmoving in the location of the original
        %target.
        precueSource = b.precue.source;
        precueSource.setRadius(targetSource.getRadius());
        precueSource.setPhase(targetSource.getPhase());
        precueSource.setAngle(targetSource.getAngle());

        %Make sure that after the changeover to the smooth target, the target
        %stll has the same (mean) contrast and wavelength.
        targetSource = b.target.source;
        targetSource.setColor(extra.color .* mot.property__(its.duration(1)) ./ mot.property__(its.dt(1)));
        targetSource.setWavelength(mot.property__(its.wavelength(:,1)));
        targetSource.setWidth(mot.property__(its.width(1)));
        
        precueSource = b.precue.source;
        precueSource.setColor(extra.color);
        precueSource.setWavelength(targetSource.getWavelength());
        precueSource.setWidth(targetSource.getWidth());
    end
        
    %minimize time between trials.
    e.trials.interTrialInterval = 0;
    
%   e.trials.fullFactorial = 1;
%   e.trials.reps = 30;
    e.trials.blockSize = 100;
    e.trials.requireSuccess = 0;
    
    %begin with an eye calibration and again every three hundred trials...
    %
    e.trials.blockTrial = EyeCalibrationMessageTrial...
        ( 'minCalibrationInterval', 0 ...
        , 'base.absoluteWindow', 100 ...
        , 'base.maxLatency', 0.5 ...
        , 'base.fixDuration', 0.5 ...
        , 'base.fixWindow', 4 ...
        , 'base.rewardDuration', 10 ...
        , 'base.settleTime', 0.3 ...
        , 'base.targetRadius', 0.2 ...
        , 'base.plotOutcome', 0 ...
        , 'base.onset', 0 ...
        , 'maxStderr', 0.5 ...
        , 'minN', 10 ...
        , 'maxN', 50 ...
        , 'interTrialInterval', 0.4 ...
        );
end
