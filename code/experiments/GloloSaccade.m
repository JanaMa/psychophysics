function e = GloloSaccade(varargin)
    e = Experiment(varargin{:});
    
    e.trials.base = GloloSaccadeTrial...
        ( 'fixation', FilledDisk ...
            ( 'radius', 0.1 ...
            , 'loc', [0 0] ...
            ) ...
        , 'fixationOnset', 0 ...
        , 'fixationTime', Inf ...
        , 'fixationLatency', 1.0 ...
        , 'fixationStartWindow', 2 ...
        , 'fixationSettle', 0.4 ...
        , 'fixationWindow', 3 ...
        , 'targetOnset', 0 ...
        , 'target', CauchyDrawer...
            ( 'source', CircularSmoothCauchyMotion ...
                ('radius', 8 ...
                , 'phase', 0 ...
                , 'angle', 90 ...            
                , 'omega', 0 ...
                , 'color', [0.125 0.125 0.125]' ...
                , 'wavelength', 1 ...
                , 'width', .75 ...
                , 'order', 4 ...
                )...
            ) ...
        , 'useTrackingTarget', 1 ...
        , 'trackingTarget', CauchySpritePlayer ...
            ('process', CircularCauchyMotion ...
                ( 'radius', 8 ...
                , 'dt', 0.15 ...
                , 'dphase', 1.5/8 ...
                , 'x', 0 ...
                , 'y', 0 ...
                , 't', 0.15 ...
                , 'n', Inf ...
                , 'color', [0.5 0.5 0.5]' ...
                , 'velocity', 10 ... %velocity of peak spatial frequency
                , 'wavelength', 0.75 ...
                , 'width', .75 ...
                , 'duration', 0.1 ...
                , 'order', 4 ...
                ) ...
            ) ...
        , 'targetBlank', Inf ...
        , 'cueTime', 0.625 ... %assuming 200ms latency, this places most saccades right in between for max. effect
        , 'maxLatency', 0.4 ...
        , 'maxTransitTime', 0.1 ...
        , 'targetWindow', 5 ...
        , 'rewardSize', 50 ...
        , 'rewardTargetBonus', 0.0 ...
        , 'errorTimeout', 0.0 ...
        );
    
    %the targets move clockwise or counterclockwise at a certain speed.
    e.trials.add({'target.source.omega', 'trackingTarget.process.dphase'}, {{-10/8 -10/8*.15} {10/8 10/8*.15}});

    %the target onset comes at a somewhat unpredictable time.
    e.trials.add('targetOnset', ExponentialDistribution('offset', 0, 'tau', 0.15));
    
    e.trials.add('cueTime', ExponentialDistribution('offset', 0.55, 'tau', 0.25));

    %the targets come up at an unknown location around the circle.
    e.trials.add('target.source.phase', UniformDistribution('lower', 0, 'upper', 2*pi));
    e.trials.add('target.source.angle', @(b) b.target.source.phase * 180/pi + 90);
    e.trials.add('trackingTarget.process.phase', @(b) b.target.source.phase + b.trackingTarget.process.t * b.target.source.omega);
    e.trials.add('trackingTarget.process.angle', @(b) b.trackingTarget.process.phase * 180/pi + 90);

    %We manipulate the local velocities. both in wavelength-scaling adn in frequency-scaling.    
        e.trials.add...
        ( {'useTrackingTarget', 'extra.wavelengthScaling', 'trackingTarget.process.velocity', 'trackingTarget.process.color', 'trackingTarget.process.wavelength'} ...
        , ...
            { {1 0   -5     [.5    .5     .5  ]' 0.375} ...
            , {1 1    5     [.5    .5     .5  ]' 0.375} ...
            , {0 1    5     [.5    .5     .5  ]' 0.375} ...
            , {1 0.5 -10    [.25    .25   .25 ]' .75} ...
            , {1 0.5 10     [.25    .25   .25 ]' .75} ...
            , {0 0.5 10     [.25    .25   .25 ]' .75} ...
            , {1 1   -15    [1/6 1/6 1/6      ]' 1.125} ...
            , {1 1   15     [1/6 1/6 1/6      ]' 1.125} ...
            , {0 1   15     [1/6 1/6 1/6      ]' 1.125} ...
            , {1 0   0      [.25    .25   .25 ]' .75} ...
            , {1 0   -5     [.25    .25   .25 ]' .75} ...
            , {1 0   5      [.25    .25   .25 ]' .75} ...
            , {1 0   -15    [.25    .25   .25 ]' .75} ...
            , {1 0   15     [.25    .25   .25 ]' .75} ...
            } ...
        );
    
        e.trials.add('targetOnset', @(b)b.targetOnset + b.useTrackingTarget * 0.15);

    %Make sure that after the changeover to the smooth target, the target
    %stll has the same mean contrast and wavelength.
    e.trials.add ...
        ( {'target.source.color', 'target.source.wavelength'} ...
        , @(b) {b.trackingTarget.process.color * b.trackingTarget.process.duration / b.trackingTarget.process.dt, b.trackingTarget.process.wavelength} ...
        );
    
    e.trials.interTrialInterval = 0.5;
    
    e.trials.fullFactorial = 1;
    e.trials.reps = 30;
    e.trials.blockSize = 170;
    
    e.trials.requireSuccess = 1;
    
    %we may wish to also sample temporal frequency, in the same trial
    %set...
    
    %target tracking time
    e.trials.add('targetFixationTime', ExponentialDistribution('offset', 0.3, 'tau', 0.2));
    
    %begin with an eye calibration and again every 10 minutes...
    e.trials.blockTrial = EyeCalibrationMessageTrial();
    e.trials.blockTrial.base.absoluteWindow = 100;
    e.trials.blockTrial.base.maxLatency = 0.5;
    e.trials.blockTrial.base.fixDuration = 0.5;
    e.trials.blockTrial.base.fixWindow = 4;
    e.trials.blockTrial.base.rewardDuration = 100;
    e.trials.blockTrial.base.settleTime = 0.4;
    e.trials.blockTrial.base.targetRadius = 0.2;
    e.trials.blockTrial.minCalibrationInterval = 0;
    e.trials.blockTrial.base.onset = 0;
    e.trials.blockTrial.maxStderr = 0.3;
    e.trials.blockTrial.minN = 20;
    e.trials.blockTrial.maxN = 50;
    e.trials.blockTrial.interTrialInterval = 0.2;  
    e.trials.startTrial = MessageTrial('message', @()sprintf('Follow the moving target with your eyes when fixation point diasappears.\n%d blocks remain.\nPress space to begin calibration.', e.trials.blocksLeft()));
    e.trials.endBlockTrial = MessageTrial('message', @()sprintf('%d blocks remain.\nPress space to continue.', e.trials.blocksLeft()));
    e.trials.endTrial = MessageTrial('message', sprintf('All done!\nPress space to finish.\nThanks!'));
    
end
