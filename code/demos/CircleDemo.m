function this = CircleDemo(varargin)

    radius = 5;
    lobes = 36;
    flanker_lobes = 3/2*lobes;
    tfreq = 10;
    tseparation = 10;
    flanker_radii = [8];
    n = 6; %number of flankers around a circle
    carrier_strength = -.3;
    contrast = 1/3;
    oscillation_amp = 1/2;
    envelope_step = 1/2; %1/2 a wavelength
    time_step = 1/tfreq/2;
    wheel_separation_x = 0;
    wheel_separation_y = 0;

    %we're going to show a ring with a second order motion going around
    %the outside of it...
    grating = SimpleCircularGratingSource();
    motion = CircularCauchyMotion();

    fixation = FilledDisk([0;0], 0.1, 'visible', 1);

    persistent init__;
    this = autoobject(varargin{:});

    setup();

    kb_ = KeyDown();
    t_ = Trigger();
    drawer1_ = CauchySpritePlayer('process', motion);
    drawer2_ = CircularGratingDrawer('source', grating);


    function params = run(params)
        main = mainLoop...
            ( 'input', {params.input.keyboard} ...
            , 'graphics', {fixation, drawer2_, drawer1_} ...
            , 'triggers', {kb_, t_} ...
            );

        kb_.set(main.stop, 'ESCAPE');
        t_.singleshot(always(), @start);
        params = main.go(params);
    end

    function k = start(k)
        drawer1_.setVisible(1, k.next);
        drawer2_.setVisible(1, k.next);
        fixation.setVisible(1, k.next);
    end

    function x = switchCarrier(k)
        motion.setColor( ...
            reshape(flipdim(reshape(motion.getColor(), 3, 2, []), 2), 3, []));
    end

    function demo(varargin)
       this.setup();
       %    playDemo(this, 'skipFrames', 0, varargin{:});
       playDemo(this, varargin{:});
   end

   function setup()
       gratingParams = structcbind ...
           ( struct ... % the flicker
             ( 'lobes', lobes ...
               , 'omega', [tfreq -tfreq] * 2 * pi ...
               , 'radius', radius ...
               , 'width', 1 ...
               , 'color', [1 1 1]'/6 ...
               , 'loc', [0 0]' ...
               ) ...
             , struct ... %the borders
             ( 'lobes', 0 ...
               , 'omega', 0 ...
               , 'radius', radius + [1 -1]/2 .* 1.5 ...
               , 'width', 0.1 ...
               , 'color', [1 1 1]' / 16 ...
               ) ...
             );

       %dt is determined by temporal and spatial frequency -- want
       %constructive interference for congruent and incongruent motion

       with = contrast * (1 + carrier_strength)/2;
       against = contrast * (1 - carrier_strength)/2;

       % left and right stepping motion wherein carrier and envelope
       % reverse after 1/2 revolution
       step = struct...
              ( 'dt', time_step ...
              , 't', time_step ...
              , 'dphase', 0 ...
              , 'phase', 2 * pi * envelope_step / flanker_lobes ...
              , 'angle', 360 * envelope_step / flanker_lobes ...
              );

       oscsteps = round(2*pi./step.phase * oscillation_amp);
       oscall = [(0:oscsteps-1) [oscsteps:-1:1]];
       oscvel = reshape(repmat([-1 1], oscsteps, 1), 1, []);

       oscillation = structcbind ...
           ( struct...
             ( 'phase', oscall ...
               , 'angle', oscall ...
               , 'dt', numel(oscall) ...
               , 't', 1:(2*oscsteps) ...
               , 'velocity', oscvel ...
               ) ...
             );

       oscmotion = expand_struct_grid(step, oscillation);

       distribution = struct ...
           ( 'phase', (0:(n-1)).* 2.*pi/n ...
             , 'angle', (0:n-1) * 360/n - 90 ...
        );

    distmotion = expand_struct_grid(oscmotion, distribution, @plus);

    spotParams = structcbind ...
        ( struct ...
          ( 'radius', flanker_radii ...
          , 'x', 0 ...
          , 'y', 0 ...
          , 'wavelength', 2*pi.*flanker_radii./flanker_lobes ...
          , 'velocity', 2*pi.*flanker_radii./flanker_lobes .* tfreq ...
          , 'width', 1 ...
          , 'duration', 1./tfreq ...
          ) ...
        );

    counterphase = struct...
        ( 'velocity', [1 -1] ...
        , 'color', [1;1;1]*[with against] ...
        );

    motionParams = cellreduce ...
        ( @expand_struct_grid, spotParams ...
        , {counterphase, distmotion} ...
        );

    motion.property__(motionParams);
    grating.property__(gratingParams);
end

end
