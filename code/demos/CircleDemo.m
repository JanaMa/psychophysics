function this = CircleDemo(varargin)

    radius = 5;
    lobes = 36;
    flanker_lobes = 54;
    tfreq = 10;
    tseparation = 10;
    flanker_radii = [7.5];
    n = 6; %number of flankers around a circle
    carrier_strength = .3;
    contrast = 0.3;
    oscillation_amp = 1/2;
    oscillation_period = 6;
    envelope_step = 1/2; %1/2 a wavelength
    time_step = 1/2;
    x_locations = [0];
    y_locations = [0];
    v_locations = [-1];
    e_locations = [1];
    interactive = 1;
    stopafterloops = 0;
    objects = {};

    params = struct...
        ( 'edfname',    '' ...
        , 'dummy',      1  ...
        , 'preferences', struct('skipSyncTests', 1, 'TextAntiAliasing', 1 ) ...
        , 'requireCalibration', 0 ...
        , 'hideCursor', 0 ...
        , 'aviout', '' ...
        , 'priority', 0 ...
        );

    %we're going to show a ring with a second order motion going around
    %the outside of it...
    grating = SimpleCircularGratingSource();
    motion = CircularCauchyMotion();

    fixation = FilledDisk([x_locations; y_locations], 0.15, 'visible', 1);

    persistent init__;
    this = autoobject(varargin{:});

    setup();

    kb_ = KeyDown();
    t_ = Trigger();
    drawer1_ = CauchySpritePlayer('process', motion);
    drawer2_ = CircularGratingDrawer('source', grating);

    function params = run(params)
        main = mainLoop...
            ( 'input', {params.input.keyboard} ...
            , 'graphics', {fixation, drawer2_, drawer1_, objects{:}} ...
            , 'triggers', {kb_, t_} ...
            );

        kb_.set(main.stop, 'ESCAPE');
        t_.singleshot(always(), @start);

        my_ = Genitive();

        if interactive
            kb_.set(@switchCarrier, 'c');
            kb_.set(@switchEnvelope, 'e');
            kb_.set(change(my_.n, @plus, 1, range(1, 20)), 'UpArrow');
            kb_.set(change(my_.n, @plus, -1, range(1, 20)), 'DownArrow');
            kb_.set(change( my_.envelope_step, @plus, 1/2 ...
                          , range(0, 3)), 'RightArrow');
            kb_.set( change(my_.envelope_step, @minus, 1/2, range(0, 3)) ...
                   , 'LeftArrow');
            kb_.set(change( my_.carrier_strength, @minus, 0.1 ...
                          , range(-0.001, 1.001)) ...
                   , '[{');
            kb_.set(change( my_.carrier_strength, @plus, 0.1 ...
                          , range(-0.001, 1.001)), ']}');
            kb_.set(change(my_.time_step, @plus, 0.5, range(0.499, 2)), '.>');
            kb_.set(change(my_.time_step, @minus, 0.5, range(0.499, 2)), ',<');
            kb_.set(change(my_.contrast, @plus, 0.1, range(0.099, 1)), '9(');
            kb_.set(change(my_.contrast, @minus, 0.1, range(0.099, 1)), '0)');
        end

        params = main.go(params);

        function k = start(k)
            drawer1_.setVisible(1, k.next);
            drawer2_.setVisible(1, k.next);
            fixation.setVisible(1, k.next);
            looplength = motion.getDt();
            if stopafterloops
                t_.singleshot ...
                    ( atLeast ...
                      ( 'next' ...
                        , k.next + params.cal.interval/2 ...
                          + looplength * stopafterloops) ...
                      , main.stop ...
                      );
            end
        end

        function f = change(what, how, by, check)
            f = @doChange;
            function doChange(k)
                x = this.property__(what);
                newX = how(x, by);
                if check(newX)
                    this.property__(what, newX);
                    x = newX;
                    setup();
                    drawer1_.setVisible(0);
                    t_.singleshot(always(), @start);
                end
                disp([substruct2str(what) ' = '])
                disp(x)
            end
        end

        function x = switchCarrier(k)
            v_locations = -v_locations;
            %shortcut...
            motion.setColor( ...
                reshape(flipdim(reshape(motion.getColor(), 3, 2, []), 2), 3, []));
            motion.reset()
            drawer1_.setVisible(0);
            t_.singleshot(always(), @start);
        end

        function x = switchEnvelope(k)
            e_locations = -e_locations;
            %shortcut...
            motion.setDphase( -motion.getDphase() );
            motion.setPhase( -motion.getPhase() );
            motion.setAngle( -motion.getAngle() );
            drawer1_.setVisible(0);
            t_.singleshot(always(), @start);
        end
    end

    function f = range(min, max)
        f = @check;
        function yn = check(x)
            yn = all(x <= max & x >= min);
        end
    end

    function demo(varargin)
       this.setup();
       %    playDemo(this, 'skipFrames', 0, varargin{:});
       playDemo(this, varargin{:});
    end

    function setup()
        flicker = struct ... % the flicker
                  ( 'lobes', lobes ...
                    , 'omega', [tfreq -tfreq] * 2 * pi ...
                    , 'radius', radius ...
                    , 'width', 1 ...
                    , 'color', [1 1 1]'/8 ...
                    );

        borders = struct ...
                  ( 'lobes', 0 ...
                  , 'omega', 0 ...
                  , 'radius', radius + [1 -1]/2 .* 1.5 ...
                  , 'width', 0.1 ...
                  , 'color', [1 1 1]' / 12 ...
                  );

        grating_placement = struct( 'loc', [x_locations; y_locations] );

        gratingParams = expand_struct_grid...
            ( structcbind(flicker, borders) ...
            , grating_placement ...
            );

        %dt is determined by temporal and spatial frequency -- want
        %constructive interference for congruent and incongruent motion

        with = contrast * (1 + carrier_strength)/2;
        against = contrast * (1 - carrier_strength)/2;

        % left and right stepping motion wherein carrier and envelope
        % reverse after 1/2 revolution
        step = struct...
               ( 'dt', 1/tfreq*time_step ...
               , 't', 1/tfreq*time_step ...
               , 'dphase', 0 ...
               , 'phase', 2 * pi * envelope_step / flanker_lobes ...
               , 'angle', 360 * envelope_step / flanker_lobes ...
               );

        oscsteps = round(2*pi./step.phase * oscillation_amp);
        oscsteps = min(oscsteps, round(oscillation_period*tfreq/time_step/2));
        oscall = [(0:oscsteps-1) [oscsteps:-1:1]];
        oscvel = reshape(repmat([-1 1], oscsteps, 1), 1, []);

        oscillation = structcbind ...
            ( struct...
              ( 'phase', oscall ...
              , 'angle', oscall ...
              , 'dt', numel(oscall) ...
              , 't', 1:(2*oscsteps) ...
              , 'velocity', oscvel ...
              ) ...
            );

        flanker_placement = structcbind...
            ( struct ...
              ( 'x', x_locations ...
              , 'y', y_locations ...
              , 'velocity', v_locations ...
              , 'phase', e_locations ...
              , 'dphase', e_locations ...
              , 'angle', e_locations ...
              ));

        oscmotion = cellreduce...
            ( @expand_struct_grid, step ...
            , {flanker_placement, oscillation} ...
            );

        distribution = structcbind...
            (struct ...
             ( 'phase', (0:(n-1)).* 2.*pi/n ...
             , 'angle', (0:n-1) * 360/n - 90 ...
             , 't', -1/tfreq*time_step ...
             ));

        distmotion = expand_struct_grid(oscmotion, distribution, @plus);

        spotParams = structcbind ...
            ( struct ...
              ( 'radius', flanker_radii ...
              , 'wavelength', 2*pi.*flanker_radii./flanker_lobes ...
              , 'velocity', 2*pi.*flanker_radii./flanker_lobes .* tfreq ...
              , 'width', 1 ...
              , 'duration', 1/tfreq ...
              ) ...
            );

        counterphase = struct...
            ( 'velocity', [1 -1] ...
            , 'color', [1;1;1]*[with against] ...
            );

        motionParams = cellreduce ...
            ( @expand_struct_grid, spotParams ...
            , {counterphase, distmotion} ...
            );

        motion.property__(motionParams);
        grating.property__(gratingParams);
        fixation.setLoc([x_locations; y_locations])
    end
 end
