function this = CircleDemo(varargin)

    radius = 5;
    lobes = 36;
    flanker_lobes = 3/2*lobes
    tfreq = 10;

    %we're going to show a ring with a second order motion going around
    %the outside of it...

    gratingParams = structcbind ...
        ( struct ... % the flicker
          ( 'lobes', lobes ...
          , 'omega', [tfreq -tfreq] * 2 * pi ...
          , 'radius', radius ...
          , 'width', 1 ...
          , 'color', [1 1 1]'/6 ...
          , 'loc', [0 0]' ...
          ) ...
        , struct ... %the borders
          ( 'lobes', 0 ...
          , 'omega', 0 ...
          , 'radius', radius + [1 -1]/2 .* 1.5 ...
          , 'width', 0.1 ...
          , 'color', [1 1 1]' / 16 ...
          ) ...
        );
    grating = SimpleCircularGratingSource(gratingParams);

    flanker_radii = [8];
    n = 6; %number of flankers around a circle

    %dt is determined by temporal and spatial frequency -- want
    %constructive interference for congruent and incongruent motion

    carrier_strength = -.2;
    contrast = 1/3;
    with = contrast * (1 + carrier_strength)/2;
    against = contrast * (1 - carrier_strength)/2;

    % left and right stepping motion wherein carrier and envelope
    % reverse after 1/2 revolution
    step = struct...
             ( 'dt', 1./tfreq .* 1/2 ...
             , 't', 1./tfreq .* 1/2 ...
             , 'dphase', 0 ...
             , 'phase', 2 * pi * 1/2 / flanker_lobes ...
             , 'angle', 360 * 1/2 / flanker_lobes ...
             );

    oscsteps = round(pi./step.phase);
    oscall = [(0:oscsteps-1) [oscsteps:-1:1]];
    oscvel = reshape(repmat([-1 1], oscsteps, 1), 1, []);

    oscillation = structcbind ...
        ( struct...
          ( 'phase', oscall ...
          , 'angle', oscall ...
          , 'dt', numel(oscall) ...
          , 't', 1:(2*oscsteps) ...
          , 'velocity', oscvel ...
          ) ...
        );

    oscmotion = expand_struct_grid(step, oscillation);

    distribution = struct ...
        ( 'phase', (0:(n-1)).* 2.*pi/n ...
        , 'angle', 90 + (0:n-1) * 360/n ...
        );

    distmotion = expand_struct_grid(oscmotion, distribution, @plus);

    spotParams = structcbind ...
        ( struct ...
          ( 'radius', flanker_radii ...
          , 'x', 0 ...
          , 'y', 0 ...
          , 'wavelength', 2*pi.*flanker_radii./flanker_lobes ...
          , 'velocity', 2*pi.*flanker_radii./flanker_lobes .* tfreq ...
          , 'width', 1 ...
          , 'duration', 1./tfreq ...
          ) ...
        );

    counterphase = struct...
        ( 'velocity', [1 -1] ...
        , 'color', [1;1;1]*[with against] ...
        );

    motionParams = cellreduce ...
        ( @expand_struct_grid, spotParams ...
        , {counterphase, distmotion} ...
        );

    motion = CircularCauchyMotion(motionParams);

    fixation = FilledDisk([0;0], 0.1, 'visible', 1);

    kb_ = KeyDown();
    t_ = Trigger();
    drawer1_ = CauchySpritePlayer('process', motion);
    drawer2_ = CircularGratingDrawer('source', grating);

    persistent init__;
    this = autoobject();

    function params = run(params)
        main = mainLoop...
            ( 'input', {params.input.keyboard} ...
            , 'graphics', {fixation, drawer2_, drawer1_} ...
            , 'triggers', {kb_, t_} ...
            );

        kb_.set(main.stop, 'ESCAPE');
        kb_.set(@switchEnvelope, 'e');
        kb_.set(@switchCarrier, 'c');
        t_.singleshot(always(), @start);
        %        t_.multishot(function(x) x.get())

        params = main.go(params);
    end

    function k = start(k)
        drawer1_.setVisible(1, k.next);
        drawer2_.setVisible(1, k.next);
        fixation.setVisible(1, k.next);
    end

    function x = switchEnvelope(k)
        motion.setDphase(-motion.getDphase());
    end

    function x = switchCarrier(k)
        motion.setColor( ...
            reshape(flipdim(reshape(motion.getColor(), 3, 2, []), 2), 3, []));
    end

    %    playDemo(this, 'skipFrames', 0, varargin{:});
    playDemo(this, varargin{:});
end
