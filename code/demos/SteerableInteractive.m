function this = SteerableInteractive(varargin)

    angle_ = 37.5; %
    local_angle = 37.5;
    dt_ = .125;
    duration_ = .125 * 2/3;
    period_mult_ = 2.2/30; %controls local spatial frequency
    period_step_ = 1; %how many periods per step; controls global velocity
    velocity_factor_ = -2/3; %local velocity as a factor of global?
    outfile = '';
    
    my_ = Genitive();
    
%{
Building a fragment shader:Reading shader from file /Users/peter/eyetracking/code/graphics/CauchyShader.frag.txt ...
process_.angle = 37.5 ;
process_.arcPhase = -2.3182901677361 ;
process_.arcPhaseSkew = 0 ;
process_.arcPhaseSpacing = 0.897597901025655 ;
process_.color = [0.5;0.5;0.5];
process_.dArcPhase = 0.057835458507231 ;
process_.dLocalPhase = 0 ;
process_.dLogRadius = -0.0443787081747357 ;
process_.dt = 0.123456790123457 ;
process_.duration = 0.0823045267489712 ;
process_.localPhase = 1.5707963267949 ;
process_.logRadius = -0.594541776574023 ;
process_.logRadiusSkew = 0 ;
process_.logRadiusSpacing = 0.336645332557399 ;
process_.maxArcPhase = 3.14159265358979 ;
process_.maxLogRadius = 2.39789527279837 ;
process_.minArcPhase = -3.14159265358979 ;
process_.minLogRadius = -0.602104727201629 ;
process_.order = 5 ;
process_.phaseSkew = 0 ;
process_.phaseSkewR = 0 ;
process_.t = 151.458597097326 ;
process_.velocity_mult = -0.54 ;
process_.wavelength_mult = 0.0729 ;
process_.width_mult = 0.155555555555556 ;
process_.x = 0 ;
process_.y = 0 ;
process_.version__.function = sprintf('VortexCauchyMotion');
process_.version__.url = sprintf('');
process_.version__.revision = NaN ;
process_.version__.parents = cell(0,0);
process_ = VortexCauchyMotion(process_);
%}

    %the base preset...
    preset_ = ...
        { my_.arcPhaseSpacing, pi/3 ... %down to pi/3
        , my_.logRadiusSpacing, 0.9 ...% down to 0.3
        , my_.angle, local_angle ...
        , my_.order, 5 ...
        , my_.duration, duration_ ...
        , my_.wavelength_mult, period_mult_ ...
        , my_.dt, dt_ ...
        , my_.width_mult, 0.12 ...
        , my_.maxLogRadius, log(11) ...
        , my_.minLogRadius, log(11)-3 ...
        , my_.velocity_mult, velocity_factor_ * period_step_ * period_mult_ / dt_ ...
        , my_.dLogRadius, -period_mult_ * period_step_ * sin(angle_*pi/180) ...
        , my_.dArcPhase, period_mult_ * period_step_ * cos(angle_*pi/180) ...
        , my_.dLocalPhase, 0 ... %2*pi*period_step_ + 2*pi*dt_*period_step_*velocity_factor_ ...
        , my_.localPhase, pi/2 ...
        , my_.color, [1; 1; 1]/2 ...
        , my_.phaseSkew, 0 ...
        , my_.phaseSkewR, 0 ...
    };
    
    
    sprites = CauchySpritePlayer('process', VortexCauchyMotion(preset_{:}));
    
    process_ = sprites.getProcess();
        
    loopLength = 70;
    
    fixation = FilledDisk([0;0], 0.1, 0, 'visible', 1);
    surround = FilledAnnularSector...
        ('arcAngle',2*pi ...
        , 'innerRadius', 10 ...
        , 'outerRadius', 20 ...
        , 'visible', 1 ...
        , 'color', [0.4 0.4 0.4]*255);
    fixsurr = FilledDisk([0;0], 1, 127.5, 'visible', 1) %the "surround" for the fixation
    tracker = FilledDisk('loc', process_.currentPosition, 'radius', process_.currentSize, 'visible', 0, 'color', 160); % a 'highlighter' for the object
    
    persistent init__;
    
    this = autoobject(varargin{:});
    
    if ~isempty(outfile)
        playDemo(this, 'aviout', outfile);
    else
        playDemo(this, varargin{:});
    end
    
    function params = getParams() 
        params = struct...
        ( 'edfname',    '' ...
        , 'dummy',      1  ...
        , 'skipFrames', 0  ...
        , 'preferences', struct('skipSyncTests', 1, 'TextAntiAliasing', 0 ) ...
        , 'requireCalibration', 0 ...
        , 'hideCursor', 0 ...
        , 'aviout', '' ...
        , 'avistart', 2 ...
        , 'priority', 0 ...
        , 'inputUsed', {{'keyboard', 'knob'}} ...
        , 'cal', Calibration('distance', 180/pi, 'spacing', [20/800, 20/800]) ...
        );
        
    end
       
    function params = run(params)
        
        ttd = transformToDegrees(params.cal);
        message = Text( 'loc', ttd(params.cal.rect([1 1])) + [0.5 0.5]...
                      , 'visible', 0, 'points', 24, 'style', 1, 'color', 255);
        
        % Here is the sequence of keys, to go along with the presentation.
        % The space bar of knob press should 
        % 1 shows just a solitary local motion (no global)
        % 2 sets it in motion.
        % 3 presents a sparse field.
        % 4 presents "rings"
        % 5 presents a dense field.
        % 6 presents "spokes"
        % 7 enters a cycle.
        % 8 displays a single ring.
        
        slideshow_state = 1;
        slideshow_routines = ...
            { @solitary ...
            , @singleMotion ...
            , @sparse ...
            , @rings ...
            , @dense ...
            , @spokes ...
            , @advanceCycle ...
            , @ring ...
        };
    
        knobpress_state = 1;
        knobpress_routines = ...
            { @sparse ...
            , @rings ...
            , @dense ...
            , @spokes ...
            , @ring ...
            , @fraserRings ...
            , @fraserSpokes ...
            };
    
        cycle_state = 1;
        cycle_routines = ...
            { @sparse ...
            , @rings ...
            , @dense ...
            , @spokes ...    
        };
        
        cycle_trigger = [];
    
        density_multiplier = 1; %for knob turning
        
        trigger = Trigger();
        keys = KeyDown();
       
        main = mainLoop ...
            ( 'graphics', {tracker, sprites, fixsurr, fixation, surround, message} ...
            , 'triggers', {trigger, keys} ...
            , 'input',    {params.input.keyboard, params.input.knob} ...
            );
        
        trigger.singleshot(atLeast('refresh', 0), @start);
        
        trigger.singleshot(keyIsDown({'LeftControl', 'ESCAPE'}, {'RightGUI', 'ESCAPE'}, 'End', 'ESCAPE'), main.stop);
        keys.set(slideshow_routines{1}, '1!');
        keys.set(slideshow_routines{2}, '2@');
        keys.set(slideshow_routines{3}, '3#');
        keys.set(slideshow_routines{4}, '4$');
        keys.set(slideshow_routines{5}, '5%');
        keys.set(slideshow_routines{6}, '6^');
        keys.set(slideshow_routines{7}, '7&');
        keys.set(@advanceSlides, 'space');
        keys.set(@toggleTracker, 'tab');
        
        keys.set(adjustmentSetter(@adjustHeading), 'h');
        keys.set(adjustmentSetter(@adjustTravel), 't');
        keys.set(adjustmentSetter(@adjustOrientation), 'o');
        keys.set(adjustmentSetter(@adjustDensity), 'd');
        keys.set(adjustmentSetter(@adjustSize), 's');
        keys.set(adjustmentSetter(@adjustSpeed), 'v');
        keys.set(adjustmentSetter(@adjustStretch), 'l');
        keys.set(adjustmentSetter(@adjustScale), 'x'); 
        keys.set(adjustmentSetter(@adjustBandwidth), 'b');
        keys.set(adjustmentSetter(@adjustPhaseSkew), 'k');
        keys.set(adjustmentSetter(@adjustPhaseSkewR), 'j');
        keys.set(adjustmentSetter(@adjustWidth), 'w');
        
        keys.set(adjustmentSetter(@adjustCircumferentialDensity), 'c');
        keys.set(adjustmentSetter(@adjustRadialDensity), 'r');
        keys.set(@dumpit, 'Return');
        
        trigger.multishot(atLeast('knobDown', 1), @advanceKnob);
        trigger.multishot(atMost('knobRotation', -1), @adjust);
        trigger.multishot(atLeast('knobRotation', 1), @adjust);
        
        hideMessageTrigger = [];
        function showMessage(status, what, timeout)
            if ~exist('timeout', 'var')
                timeout = 5;
            end
            if ~isempty(hideMessageTrigger)
                trigger.remove(hideMessageTrigger);
            end
            message.setText(what);
            message.setVisible(1);
            hideMessageTrigger = trigger.singleshot(atLeast('next', status.next + timeout), @hideMessage);
        end
        
        function hideMessage(status)
            message.setVisible(0);
            hideMessageTrigger = [];
        end
        
        function advanceKnob(status)
            stopAdvancingCycle();
            knobpress_state = mod(knobpress_state, numel(knobpress_routines)) + 1;
            showMessage(status, fname(knobpress_routines{knobpress_state}));
            knobpress_routines{knobpress_state}(status);
        end
        
        function advanceSlides(status)
            stopAdvancingCycle();
            slideshow_state = mod(slideshow_state, numel(slideshow_routines)) + 1;
            showMessage(status, fname(slideshow_routines{slideshow_state}));
            slideshow_routines{slideshow_state}(status);
        end 
        
        function advanceCycle(status)
            cycle_state = mod(cycle_state, numel(cycle_routines)) + 1;
            cycle_routines{cycle_state}(status);
            showMessage(status, fname(cycle_routines{cycle_state}));
            cycle_trigger = trigger.singleshot(atLeast('next', status.next + floor(loopLength * 1.25) * dt_  - 0.005),    @advanceCycle);
        end
        
        function stopAdvancingCycle(params)
            if ~isempty(cycle_trigger)
                trigger.remove(cycle_trigger);
                cycle_trigger = [];
            end
        end
        
        function showTracker(status)
            tracker.setVisible(1);
            showMessage(status, 'tracker');
        end
        
        function hideTracker(status)
            tracker.setVisible(0);
            showMessage(status, ' ');
        end
        
        function toggleTracker(status)
            tracker.setVisible(~tracker.getVisible());
        end
        
        function solitary(params)
            stopAdvancingCycle();
            
            process_.property__ ...
                (preset_{:} ...
                , my_.arcPhaseSpacing, 2*pi ...
                , my_.logRadiusSpacing, 3 ...
                , my_.dLogRadius, 0 ...
            	, my_.dArcPhase, 0 ...
                , my_.arcPhase, 3*pi/2 ...
                , my_.logRadius, 2 ...
                );
            
            showMessage(params, sprintf(' \n \n \n \n \n \n          The Steerable Spiral\n          Peter Meilstrup & Michael Shadlen\n          University of Washington'), Inf);
        end
        
        function singleMotion(params)
            stopAdvancingCycle();
            process_.resetCounter();
            process_.property__...
                ( preset_{:} ...
                , my_.arcPhaseSpacing, 2*pi ...
                , my_.logRadiusSpacing, 3 ...
                );
        end
        
        %state variables say whether to adjust density radially or
        %circumferentially
        densityCircumferential = 1;
        densityRadial = 1;
        
        function sparse(status)
            hideTracker(status);
            process_.property__ ...
                ( preset_{:} ...
                , my_.arcPhaseSpacing, pi/3 ...
                , my_.logRadiusSpacing, 0.9 ...
                , my_.arcPhaseSkew,  0 ...
                , my_.logRadiusSkew, 0 ...
            )
            
            densityCircumferential = 1;
            densityRadial = 1;
        end
    
        function rings(status)
            hideTracker(status);
            process_.property__ ...
                ( preset_{:} ...
                , my_.arcPhaseSpacing, pi/9 ...
                , my_.logRadiusSpacing, 0.9 ...
                , my_.arcPhaseSkew,  0 ...
                , my_.logRadiusSkew, 0 ...
            )
            
            densityCircumferential = 1;
            densityRadial = 0;
        end
        
        function dense(status)
            hideTracker(status);
            process_.property__ ...
                ( preset_{:} ...
                , my_.arcPhaseSpacing, pi/9 ...
                , my_.logRadiusSpacing, 0.3 ...
                , my_.arcPhaseSkew,  5/18 ...
                , my_.logRadiusSkew, 13/18 ...
            )
            
            densityCircumferential = 1;
            densityRadial = 1;
        end
        
        function spokes(status)
            hideTracker(status);
            process_.property__ ...
                ( preset_{:} ...
                , my_.arcPhaseSpacing, pi/3 ...
                , my_.logRadiusSpacing, 0.3 ...
                , my_.arcPhaseSkew,  0 ...
                , my_.logRadiusSkew, 1/6 ...
            )
            
            densityCircumferential = 0;
            densityRadial = 1;
        end
        
        function ring(status)
            %a ring concentric around the fixation point...
            hideTracker(status);
            process_.property__ ...
                ( preset_{:} ...
                , my_.arcPhaseSpacing, pi/9 ...
                , my_.logRadiusSpacing, 3 ...
                , my_.arcPhaseSkew,  0 ...
                , my_.logRadiusSkew, 0 ...
                , my_.angle, 0 ...
                , my_.dArcPhase, period_mult_ * period_step_ ...
                , my_.dLogRadius, 0 ...
                , my_.logRadius, 2 ...
                )
            densityCircumferential = 1;
            densityRadial = 0;
        end
        
        function fraserRings(status)
            %a variant on the Fraser spiral...
%{
            process_.property__ ...
                ( my_.angle, 112.5 ...
                , my_.arcPhase, -3.14159265358979 ...
                , my_.arcPhaseSkew, pi/24 ...
                , my_.arcPhaseSpacing, 2*pi/24 ...
                , my_.color, [0.5;0.5;0.5] ...
                , my_.dArcPhase, 0 ...
                , my_.dLocalPhase, 0 ...
                , my_.dLogRadius, 0 ...
                , my_.dt, 0.1 ...
                , my_.duration, 0.15 ...
                , my_.localPhase, 1.5707963267949 ...
                , my_.logRadius, 2 ...
                , my_.logRadiusSkew, 0 ...
                , my_.logRadiusSpacing, 0.43046721 ...
                , my_.maxArcPhase, 3.14159265358979 ...
                , my_.maxLogRadius, 2.39789527279837 ...
                , my_.minArcPhase, -3.14159265358979 ...
                , my_.minLogRadius, -0.602104727201629 ...
                , my_.order, 2.1 ...
                , my_.phaseSkew, -7 ...
                , my_.velocity_mult, 0 ...
                , my_.wavelength_mult, 0.04 ...
                , my_.width_mult, 0.25 ...
                );
%}
            process_.property__ ...
                ( my_.angle, 71.25 ...
                , my_.arcPhase, -3.14159265358979 ...
                , my_.arcPhaseSkew, 0.130899693899575 ...
                , my_.arcPhaseSpacing, 2*pi/24 ... %0.273181969877373 ...
                , my_.color, [0.5;0.5;0.5] ...
                , my_.dArcPhase, 0 ...
                , my_.dLocalPhase, 0 ...
                , my_.dLogRadius, 0 ...
                , my_.dt, 0.1 ...
                , my_.duration, 0.15 ...
                , my_.localPhase, 1.5707963267949 ...
                , my_.logRadius, 2 ...
                , my_.logRadiusSkew, 0 ...
                , my_.logRadiusSpacing, 0.387420489 ...
                , my_.maxArcPhase, 3.14159265358979 ...
                , my_.maxLogRadius, 2.39789527279837 ...
                , my_.minArcPhase, -3.14159265358979 ...
                , my_.minLogRadius, -0.602104727201629 ...
                , my_.order, 1.37781000000001 ...
                , my_.phaseSkew, -12 ... %19
                , my_.velocity_mult, 0 ...
                , my_.wavelength_mult, 0.0324000000000001 ...
                , my_.width_mult, 0.202500000000001 ...
                )

            densityCircumferential = 0;
            densityRadial = 1;
        end
        
        function fraserSpokes(status) 
            process_.property__ ...
                ( my_.angle, 75 ...
                , my_.arcPhase, -3.14159265358979 ...
                , my_.arcPhaseSkew, 0 ...
                , my_.arcPhaseSpacing, 2*pi/19 ...
                , my_.color, [0.5;0.5;0.5]...
                , my_.dArcPhase, 0 ...
                , my_.dLocalPhase, 0 ...
                , my_.dLogRadius, 0 ...
                , my_.dt, 0.1 ...
                , my_.duration, 0.15 ...
                , my_.localPhase, 1.5707963267949 ...
                , my_.logRadius, -0.5787095168329 ...
                , my_.logRadiusSkew, 0 ...
                , my_.logRadiusSpacing, 0.198785702421819 ...
                , my_.maxArcPhase, 3.14159265358979 ...
                , my_.maxLogRadius, 2.39789527279837 ...
                , my_.minArcPhase, -3.14159265358979 ...
                , my_.minLogRadius, -0.602104727201629 ...
                , my_.order, 1.2 ...
                , my_.phaseSkew, 5  ...
                , my_.phaseSkewR, .5 ...
                , my_.velocity_mult, 0 ...
                , my_.wavelength_mult, 0.06 ...
                , my_.width_mult, 0.1 ...
                );
            densityCircumferential = 1;
            densityRadial = 0;
        end
        
        
        

        function start(status)
            %the tracker time index should be synchronized to the sprite.
            sprites.setVisible(1, status.next);
            tracker.setVisible(0, status.next);
            solitary(status);
        end
        
        adjustment = @adjustDensity;
        function fn = adjustmentSetter(what)
            fn = @setit;
            function setit(status)
                adjustment = what;
                showMessage(status, fname(what));
            end
        end
        
        function adjust(status)
            howmuch = status.knobRotation;
            adjustment(status, howmuch)
        end
        
        adjustmentFactor = 0.9;
        
        function factor = adjustDensity(status, howmuch)            
            circumferential = process_.getArcPhaseSpacing();
            logradial = process_.getLogRadiusSpacing();
            
            if densityCircumferential
                n = round(2*pi/circumferential);
                if n <= 1 && howmuch < 1
                    showMessage(status, 'limit reached', 1);
                    factor = 1;
                    return;
                end
                process_.resetCounter();
                %we adjust for the number of targets circumferentially, and
                %radial by hte same factor.
                factor = n / min(100, max(1,(n + howmuch)));
                circumferential = 2*pi / max(1,(n + howmuch));
                if densityRadial
                    logradial = logradial * factor;
                end
            elseif densityRadial
                process_.resetCounter();
                %adjust at a constant rate
                factor = adjustmentFactor^(howmuch/3);
                logradial = logradial * factor;
            end
            
            if (logradial * circumferential < 1/20 || logradial < 1/10 || circumferential < 1/10)
                factor = 1;
                showMessage(status, 'limit reached', 1);
                return;
            end
            process_.setArcPhaseSpacing(circumferential);
            process_.setLogRadiusSpacing(logradial);
        end
        
        function adjustCircumferentialDensity(status, howmuch)
            circumferential = process_.getArcPhaseSpacing();
            logradial = process_.getLogRadiusSpacing();
            
            n = round(2*pi/circumferential);
            if n <= 1 && howmuch < 1
                showMessage(status, 'limit reached', 1);
                return;
            end
            %we adjust for the number of targets circumferentially, and
            %radial by hte same factor.
            
            if (logradial * circumferential < 1/20 || logradial < 1/10 || circumferential < 1/10)
                showMessage(status, 'limit reached', 1);
                return;
            end
            process_.resetCounter();

            circumferential = 2*pi / max(1,(n + howmuch));
            process_.setArcPhaseSpacing(circumferential);
        end
        
        function adjustRadialDensity(status, howmuch)
            circumferential = process_.getArcPhaseSpacing();
            logradial = process_.getLogRadiusSpacing();
            process_.resetCounter();
            %adjust at a constant rate
            logradial = logradial * adjustmentFactor^(howmuch/3);
            if (logradial * circumferential < 1/20) || (logradial < 1/10) || (circumferential < 1/10)
                showMessage(status, 'limit reached', 1);
                return;
            end

            process_.resetCounter();
            process_.setLogRadiusSpacing(logradial);
        end
        
        
        function adjustOrientation(status, howmuch)
            process_.setAngle(process_.getAngle() - howmuch * 3.75);
        end
        
        function adjustHeading(status, howmuch)
            direction = [process_.getDLogRadius(); process_.getDArcPhase()];
            radians = howmuch*pi/48;
            
            rotation = [cos(radians) sin(radians); -sin(radians) cos(radians)];
            direction = rotation * direction;
            
            process_.resetCounter();
            process_.setDLogRadius(direction(1,:));
            process_.setDArcPhase(direction(2,:));
        end
        
        function adjustTravel(status, howmuch)
            adjustHeading(status, howmuch);
            adjustOrientation(status, howmuch);
        end
        
        function adjustSize(status, howmuch)
            %adjust the size of the blobs (width, period, and velocity)
            %without adjusting the delta-t.
            adjustMultiplicatively...
                ( status ...
                , {my_.width_mult, my_.wavelength_mult, my_.velocity_mult}...
                , [1 1 1] * howmuch ...
                , [0 1/50 0] ...
                , [Inf 1 Inf] ...
                );
        end
        
        function adjustSpeed(status, howmuch)
            %adjust the raw speed (dt, duration, velocity in sync)
            process_.resetCounter();
            adjustMultiplicatively...
                ( status ...
                , {my_.dt, my_.duration, my_.velocity_mult}...
                , howmuch * [1 1 -1] ...
                , [1/60, 0,   0] ...
                , [2,    Inf, Inf] ...
                );
        end
        
        function adjustStretch(status, howmuch)
            %"stretch" the stimulus aling the direction of motion
            process_.resetCounter();
            adjustMultiplicatively ...
                ( status ...
                , {my_.wavelength_mult, my_.dArcPhase, my_.dLogRadius} ...
                , [1 1 1] * howmuch  ...
                , [1/100  0   0  ] ...
                , [1      Inf Inf] ...
                );
        end
        
        function adjustScale(status, howmuch)
            %Scale the density with the other spatial aspects....
            factor = adjustDensity(status, howmuch);
            adjustMultiplicatively...
                ( status ...
                , {my_.width_mult, my_.wavelength_mult, my_.velocity_mult, my_.dArcPhase, my_.dLogRadius}...
                , [1 1 1 1 1] * log(factor)/log(adjustmentFactor) ...
                , [0 0 0 0 0] ...
                , [Inf Inf Inf Inf Inf] ...
                );
        end
        
        function adjustBandwidth(status, howmuch)
            %tweak the bandwidth
            adjustMultiplicatively...
                ( status ...
                , {my_.order}...
                , 1 * howmuch ...
                , [1] ...
                , [30] ...
                );
        end
        
               
        function adjustWidth(status, howmuch)
            %tweak the bandwidth
            adjustMultiplicatively...
                ( status ...
                , {my_.width_mult}...
                , 1 * howmuch ...
                , [0.02] ...
                , [2] ...
                );
        end

        
        function adjustPhaseSkew(status, howmuch)
            process_.setPhaseSkew(process_.getPhaseSkew() + howmuch);
        end
        
        function adjustPhaseSkewR(status, howmuch)
            process_.setPhaseSkewR(process_.getPhaseSkewR() + howmuch/4);
        end

        
        function dumpit(what)
            %dump for future reference.
            dump(process_);
            main.stop();
        end
        
        function adjustMultiplicatively(status, properties, howmuch, minlimits, maxlimits)
            %adjust a group of properties
            new = cellfun(@(prop, howm) process_.property__(prop) * adjustmentFactor ^ howm, properties, num2cell(howmuch), 'UniformOutput', 0);
            if any(abs([new{:}]) < minlimits | abs([new{:}]) > maxlimits)
                showMessage(status, 'limit reached', 1);
                return
            end
            args = {properties{:}; new{:}};
            process_.property__(args{:});
        end
        
        function name = fname(fn)
            name = regexp(func2str(fn), '(?<=/)[^/]*$', 'match', 'once')
        end
            
        params = main.go(params);
    end
end

